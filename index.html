<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>用電紀錄小工具（雲端版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- 粗體黃色閃電 favicon -->
  <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMTMgMkg3TDEyIDlIN0wxMiAyMkwxMyAxNEgxOEwxMyAyWiIgZmlsbD0iI0ZGRDAwMCIgc3Ryb2tlPSJub25lIi8+Cjwvc3ZnPg==">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }

    .card {
      background: #ffffff;
      border-radius: 8px;
      padding: 16px 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      margin-bottom: 16px;
    }

    label {
      display: block;
      margin: 8px 0 4px;
      font-size: 0.9rem;
    }

    input[type="number"],
    input[type="datetime-local"],
    input[type="date"],
    input[type="month"],
    select,
    textarea {
      width: 100%;
      max-width: 320px;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      font-size: 0.9rem;
      font-family: inherit;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-start;
    }

    .checkbox-inline {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      font-size: 0.9rem;
    }

    button {
      padding: 8px 12px;
      margin-top: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    button.primary {
      background-color: #3b82f6;
      color: white;
    }

    button.secondary {
      background-color: #e5e7eb;
      color: #111827;
    }

    button.danger {
      background-color: #ef4444;
      color: white;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .table-wrapper {
      width: 100%;
      overflow-x: auto;
      margin-top: 8px;
    }

    table {
      min-width: 650px;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
    }

    th {
      background: #f3f4f6;
    }

    tbody tr:nth-child(even) {
      background: #f9fafb;
    }

    .small-text {
      font-size: 0.8rem;
      color: #6b7280;
      margin-top: 4px;
    }

    .summary {
      font-size: 0.85rem;
      color: #374151;
    }

    .summary span {
      display: inline-block;
      margin-right: 16px;
      margin-top: 4px;
    }

    .warning {
      color: #b91c1c;
      font-size: 0.8rem;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.75rem;
      background-color: #e5e7eb;
      color: #374151;
      margin-left: 4px;
    }

    /* 管理所有紀錄 modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-content {
      background: #ffffff;
      max-width: 960px;
      width: 95%;
      max-height: 90vh;
      overflow: auto;
      border-radius: 8px;
      padding: 16px 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    @media (max-width: 600px) {
      body {
        margin: 10px;
      }

      .row {
        flex-direction: column;
        gap: 8px;
      }

      input[type="number"],
      input[type="datetime-local"],
      input[type="date"],
      input[type="month"],
      select,
      textarea {
        max-width: 100%;
      }

      button {
        width: 100%;
      }

      .card {
        padding: 12px 14px;
      }

      h1 {
        font-size: 1.2rem;
      }
    }
  </style>

  <!-- Chart.js：用來畫折線圖 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>用電紀錄與每小時平均用電（雲端版）⚡</h1>

  <!-- 新增單筆紀錄 -->
  <div class="card">
    <h2 style="font-size:1.1rem;margin-top:0;">新增紀錄</h2>
    <div class="row">
      <div>
        <label for="reading">電表讀數（度）</label>
        <input type="number" id="reading" step="0.01" placeholder="例如：39564.0">
      </div>

      <div>
        <label for="record-time">紀錄時間</label>
        <input type="datetime-local" id="record-time">
        <div class="checkbox-inline">
          <input type="checkbox" id="use-now" checked>
          <label for="use-now" style="margin:0;">使用現在時間（自動抓取）</label>
        </div>
        <div class="small-text">
          若勾選「使用現在時間」，下方時間欄位可留空。<br>
          若要補紀錄過去時間，請取消勾選並自行選擇時間。
        </div>
      </div>
    </div>

    <button class="primary" id="add-btn">新增紀錄</button>
  </div>

  <!-- 紀錄列表（最近 10 筆） -->
  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:flex-start;">
      <div>
        <h2 style="font-size:1.1rem;margin-top:0;">紀錄列表（最近 10 筆，最新在上）</h2>
        <div id="summary" class="summary"></div>
      </div>
      <div>
        <button class="secondary" id="manage-btn">管理所有紀錄</button>
        <button class="secondary" id="export-btn">匯出目前資料（JSON）</button>
        <button class="danger" id="clear-btn">清除全部紀錄（雲端）</button>
      </div>
    </div>

    <div class="table-wrapper">
      <div id="table-container"></div>
    </div>
    <div class="small-text">
      計算方式：每小時平均用電 ＝（本次電表讀數 − 上次電表讀數） ÷ 兩次紀錄間隔小時數。<br>
      列表僅顯示最近 10 筆，統計與電費估算仍會使用全部紀錄。
    </div>
  </div>

  <!-- 用電趨勢折線圖 -->
  <div class="card">
    <h2 style="font-size:1.1rem;margin-top:0;">用電趨勢圖</h2>
    <div class="row">
      <div>
        <label for="trend-mode">顯示模式</label>
        <select id="trend-mode">
          <option value="hourly">每小時用電量（以整點統計）</option>
          <option value="daily">每日用電量（度/日）</option>
        </select>
        <div class="small-text">
          每小時：把兩筆紀錄之間的用電，平均分配到期間涵蓋的整點小時格子。<br>
          每日：以「後一筆紀錄的日期」歸戶該段用電量。
        </div>
      </div>
    </div>
    <div style="margin-top:12px;">
      <canvas id="trend-chart" style="max-width:100%;height:260px;"></canvas>
    </div>
  </div>

  <!-- 本期電費估算 -->
  <div class="card">
    <h2 style="font-size:1.1rem;margin-top:0;">本期電費估算</h2>
    <div class="row">
      <div>
        <label for="billing-start-date">本期起始抄表日</label>
        <input type="date" id="billing-start-date">
        <div class="small-text">
          例如：看帳單上的「上期抄表日期」（兩個月一期）。
        </div>
      </div>

      <div>
        <label for="billing-start-reading">本期起始電表讀數（度）</label>
        <input type="number" id="billing-start-reading" step="0.01" placeholder="例如：39048">
      </div>

      <div>
        <label for="billing-season">電價模式</label>
        <select id="billing-season">
          <option value="auto">自動判斷（依起始日期）</option>
          <option value="summer">夏月電價（6–9 月）</option>
          <option value="nonsummer">非夏月電價（10–5 月）</option>
        </select>
        <div class="small-text">
          住宅用電，採兩個月累進計價。此估算僅計入流動電費，未含其它小項目。
        </div>
      </div>
    </div>

    <button class="primary" id="billing-save-btn">儲存本期設定到雲端</button>

    <div id="billing-summary" class="small-text" style="margin-top:8px;"></div>
  </div>

  <!-- 批次匯入 -->
  <div class="card">
    <h2 style="font-size:1.1rem;margin-top:0;">批次匯入紀錄</h2>
    <div class="row">
      <div style="flex:1 1 260px;">
        <label for="batch-input">請一行一筆，格式例如：</label>
        <textarea id="batch-input" placeholder="2025/11/04 17:05:00	39638
2025/11/05 09:30:00	39680.5
2025/11/06 21:15:00	39740"></textarea>
        <div class="small-text">
          規則：
          <ul style="margin:4px 0 0 18px;padding:0;font-size:0.8rem;color:#6b7280;">
            <li>左邊是日期時間，右邊是讀數，中間用 Tab 或空白分隔</li>
            <li>支援格式：2025/11/4 17:05:00、2025/11/04 17:05、2025-11-04 17:05 等</li>
            <li>也支援「時間, 讀數」用逗號分隔</li>
          </ul>
        </div>
        <button class="primary" id="batch-import-btn">匯入以上資料到雲端</button>
      </div>
    </div>
  </div>

  <!-- 管理所有紀錄 Modal -->
  <div id="manage-modal" class="modal-overlay">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="font-size:1.1rem;margin:0;">管理所有紀錄</h2>
        <button class="secondary" id="manage-close-btn">關閉</button>
      </div>
      <div class="row" style="margin-bottom:8px;">
        <div>
          <label for="manage-month">篩選月份</label>
          <input type="month" id="manage-month">
          <div class="small-text">
            選擇某一個月份，只顯示該月紀錄；留白則顯示全部。
          </div>
        </div>
        <div style="align-self:flex-end;">
          <button class="secondary" id="manage-reset-btn">清除篩選</button>
        </div>
      </div>
      <div class="table-wrapper">
        <div id="manage-table-container"></div>
      </div>
    </div>
  </div>

  <script>
    // ======= 你的 Web App 設定 =======
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyr-CYGXoSqgq8tbXoBXjPbZTU1GpH1gWXJ1TTS9Le5SCIcyDikY3tSBymi6Lo1JZyc/exec";
    const OWNER_TOKEN = "860318";
    // ==================================

    // 台電兩個月累進電價（住宅）
    const RATE_TABLE_2M = {
      summer: [
        { limit: 240,  price: 1.68 },
        { limit: 660,  price: 2.45 },
        { limit: 1000, price: 3.70 },
        { limit: 1400, price: 5.04 },
        { limit: 2000, price: 6.24 },
        { limit: Infinity, price: 8.46 }
      ],
      nonsummer: [
        { limit: 240,  price: 1.68 },
        { limit: 660,  price: 2.16 },
        { limit: 1000, price: 3.03 },
        { limit: 1400, price: 4.14 },
        { limit: 2000, price: 5.07 },
        { limit: Infinity, price: 6.63 }
      ]
    };

    let entries = [];
    let billingConfig = null;
    let trendChart = null;

    const readingInput = document.getElementById("reading");
    const timeInput = document.getElementById("record-time");
    const useNowCheckbox = document.getElementById("use-now");
    const addBtn = document.getElementById("add-btn");
    const clearBtn = document.getElementById("clear-btn");
    const exportBtn = document.getElementById("export-btn");
    const tableContainer = document.getElementById("table-container");
    const summaryDiv = document.getElementById("summary");

    const batchInput = document.getElementById("batch-input");
    const batchImportBtn = document.getElementById("batch-import-btn");

    const billingStartDateInput = document.getElementById("billing-start-date");
    const billingStartReadingInput = document.getElementById("billing-start-reading");
    const billingSeasonSelect = document.getElementById("billing-season");
    const billingSaveBtn = document.getElementById("billing-save-btn");
    const billingSummaryDiv = document.getElementById("billing-summary");

    const trendModeSelect = document.getElementById("trend-mode");

    // 管理所有紀錄相關
    const manageBtn = document.getElementById("manage-btn");
    const manageModal = document.getElementById("manage-modal");
    const manageCloseBtn = document.getElementById("manage-close-btn");
    const manageMonthInput = document.getElementById("manage-month");
    const manageResetBtn = document.getElementById("manage-reset-btn");
    const manageTableContainer = document.getElementById("manage-table-container");

    function round(value, decimals) {
      const factor = Math.pow(10, decimals);
      return Math.round(value * factor) / factor;
    }

    function formatDateTime(isoString) {
      const d = new Date(isoString);
      if (isNaN(d.getTime())) return "時間格式錯誤";
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return `${y}-${m}-${day} ${hh}:${mm}`;
    }

    function formatDateOnly(isoString) {
      const d = new Date(isoString);
      if (isNaN(d.getTime())) return "日期錯誤";
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    // 把時間往下取整到該小時整點
    function floorToHour(dateOrIso) {
      const d = (dateOrIso instanceof Date) ? new Date(dateOrIso) : new Date(dateOrIso);
      if (isNaN(d.getTime())) return null;
      d.setMinutes(0, 0, 0);
      return d;
    }

    // 折線圖用的整點標籤
    function formatHourLabel(isoString) {
      const d = new Date(isoString);
      if (isNaN(d.getTime())) return isoString;
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      return `${m}/${day} ${hh}:00`;
    }

    function parseUserDateTime(timePart) {
      let s = timePart.trim();
      if (!s) return null;
      s = s.replace(/\//g, "-");
      const m = s.match(
        /^(\d{4})-(\d{1,2})-(\d{1,2})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/
      );
      if (m) {
        let year  = m[1];
        let month = m[2].padStart(2, "0");
        let day   = m[3].padStart(2, "0");
        let hh    = (m[4] ?? "0").padStart(2, "0");
        let mm    = (m[5] ?? "0").padStart(2, "0");
        let ss    = (m[6] ?? "0").padStart(2, "0");
        const iso = `${year}-${month}-${day}T${hh}:${mm}:${ss}`;
        const d = new Date(iso);
        if (!isNaN(d.getTime())) return d;
      }
      if (!s.includes("T") && s.includes(" ")) {
        s = s.replace(" ", "T");
      }
      const d2 = new Date(s);
      if (!isNaN(d2.getTime())) return d2;
      return null;
    }

    function getLatestEntry() {
      if (!entries || entries.length === 0) return null;
      return entries.reduce((acc, cur) => {
        return new Date(cur.timestamp) > new Date(acc.timestamp) ? cur : acc;
      });
    }

    // 電費級距：回傳總額 + 每一級明細
    function computeBillBreakdown(kwhUsed, isSummer) {
      const table = isSummer ? RATE_TABLE_2M.summer : RATE_TABLE_2M.nonsummer;
      let remaining = kwhUsed;
      let lastLimit = 0;
      let totalCost = 0;
      const tiers = [];

      for (const tier of table) {
        if (remaining <= 0) break;
        const cap = tier.limit;
        const tierRange = cap - lastLimit;
        const useInTier = Math.max(0, Math.min(remaining, tierRange));
        if (useInTier > 0) {
          const cost = useInTier * tier.price;
          tiers.push({
            from: lastLimit + 1,
            to: cap === Infinity ? Infinity : cap,
            kwh: useInTier,
            price: tier.price,
            cost
          });
          remaining -= useInTier;
          totalCost += cost;
        }
        lastLimit = cap;
      }
      return { totalCost, tiers };
    }

    function estimateBillFor2M(kwhUsed, isSummer) {
      return computeBillBreakdown(kwhUsed, isSummer).totalCost;
    }

    // ---- API ----
    async function apiGetAll() {
      const url = `${SCRIPT_URL}?action=all&token=${encodeURIComponent(OWNER_TOKEN)}`;
      const res = await fetch(url);
      const data = await res.json();
      if (!data.ok) {
        throw new Error(data.error || "取得資料失敗");
      }
      entries = data.entries || [];
      billingConfig = data.billing || null;
      applyBillingConfigToForm();
      renderTable();
    }

    async function apiPost(payload) {
      const res = await fetch(SCRIPT_URL, {
        method: "POST",
        body: JSON.stringify({ token: OWNER_TOKEN, ...payload })
      });
      const data = await res.json();
      if (!data.ok) {
        throw new Error(data.error || "操作失敗");
      }
      entries = data.entries || [];
      billingConfig = data.billing || null;
      applyBillingConfigToForm();
      renderTable();
      renderManageTable(); // 若管理視窗開著，也同步更新
    }

    // ---- billing ----
    function applyBillingConfigToForm() {
      if (!billingConfig) {
        billingSummaryDiv.textContent = "尚未設定本期起始抄表資訊。";
        billingStartDateInput.value = "";
        billingStartReadingInput.value = "";
        billingSeasonSelect.value = "auto";
        return;
      }
      billingStartDateInput.value = billingConfig.periodStartDate || "";
      if (typeof billingConfig.periodStartReading === "number") {
        billingStartReadingInput.value = billingConfig.periodStartReading;
      }
      billingSeasonSelect.value = billingConfig.seasonMode || "auto";
    }

    function getSeasonMode(config) {
      if (!config) return null;
      const mode = config.seasonMode || "auto";
      if (mode === "summer" || mode === "nonsummer") return mode;
      if (!config.periodStartDate) return "nonsummer";
      const d = new Date(config.periodStartDate + "T00:00");
      if (isNaN(d.getTime())) return "nonsummer";
      const month = d.getMonth() + 1;
      return (month >= 6 && month <= 9) ? "summer" : "nonsummer";
    }

    function updateBillingSummary() {
      if (!billingSummaryDiv) return;

      if (!billingConfig || !billingConfig.periodStartDate || typeof billingConfig.periodStartReading !== "number") {
        billingSummaryDiv.textContent = "尚未設定本期起始抄表資訊。請輸入上期帳單的起始抄表日期與度數後按「儲存本期設定到雲端」。";
        return;
      }

      if (!entries || entries.length === 0) {
        billingSummaryDiv.textContent = "目前沒有任何用電紀錄，因此無法估算本期電費。";
        return;
      }

      const latest = getLatestEntry();
      if (!latest) {
        billingSummaryDiv.textContent = "目前沒有任何用電紀錄，因此無法估算本期電費。";
        return;
      }

      const used = latest.reading - billingConfig.periodStartReading;
      if (used <= 0) {
        billingSummaryDiv.innerHTML =
          `本期起始抄表日：${billingConfig.periodStartDate}，起始度數：${billingConfig.periodStartReading} 度。<br>` +
          `最新紀錄時間：${formatDateTime(latest.timestamp)}，最新讀數：${latest.reading} 度。<br>` +
          `<span class="warning">目前讀數尚未超過起始讀數，無法估算本期電費（或起始度數設定有誤）。</span>`;
        return;
      }

      const seasonMode = getSeasonMode(billingConfig);
      const isSummer = seasonMode === "summer";
      const breakdown = computeBillBreakdown(used, isSummer);

      let seasonLabel = "";
      if (billingConfig.seasonMode === "summer") {
        seasonLabel = "（強制使用夏月電價）";
      } else if (billingConfig.seasonMode === "nonsummer") {
        seasonLabel = "（強制使用非夏月電價）";
      } else {
        seasonLabel = isSummer ? "（自動判斷為夏月電價）" : "（自動判斷為非夏月電價）";
      }

      let tierHtml = "";
      tierHtml += `<br>級距明細（兩個月度數計）：<br>`;
      tierHtml += `<ul style="margin:4px 0 0 18px;padding:0;font-size:0.8rem;">`;
      breakdown.tiers.forEach(t => {
        const rangeStr = t.to === Infinity ? `${t.from}度以上` : `${t.from}–${t.to}度`;
        tierHtml += `<li>${rangeStr}：用電約 ${round(t.kwh, 2)} 度 × ${t.price} 元/度 ≒ ${round(t.cost, 0)} 元</li>`;
      });
      tierHtml += `</ul>`;

      billingSummaryDiv.innerHTML =
        `本期起始抄表日：${billingConfig.periodStartDate}，起始度數：${billingConfig.periodStartReading} 度。<br>` +
        `最新紀錄時間：${formatDateTime(latest.timestamp)}，最新讀數：${latest.reading} 度。<br>` +
        `本期累積用電：約 <b>${round(used, 2)} 度</b><br>` +
        `估算本期電費：約 <b>${round(breakdown.totalCost, 0)} 元</b> ` +
        `<span class="badge">${isSummer ? "夏月" : "非夏月"}</span> ${seasonLabel}` +
        tierHtml +
        `<span class="small-text">※ 此為簡化估算，只依照台電住宅累進電價計算流動電費，未含基本費、再生能源加價等其它雜項。</span>`;
    }

    // ---- Summary ----
    function renderSummary(sortedAsc) {
      if (sortedAsc.length === 0) {
        summaryDiv.textContent = "目前沒有任何紀錄。請先新增一筆電表讀數。";
        return;
      }

      const first = sortedAsc[0];
      const last = sortedAsc[sortedAsc.length - 1];

      let totalHours = null;
      let totalUsed = null;
      let avgTotal = null;

      if (sortedAsc.length >= 2) {
        const startTime = new Date(first.timestamp);
        const endTime = new Date(last.timestamp);
        totalHours = (endTime - startTime) / (1000 * 60 * 60);
        totalUsed = last.reading - first.reading;
        if (totalHours > 0 && totalUsed >= 0) {
          avgTotal = totalUsed / totalHours;
        }
      }

      let html = "";
      html += `<span>總筆數（全部）：${sortedAsc.length}</span>`;
      html += `<span>最早紀錄：${formatDateTime(first.timestamp)}</span>`;
      html += `<span>最新紀錄：${formatDateTime(last.timestamp)}</span><br>`;

      if (avgTotal !== null) {
        html += `<span>整段期間總用電：${round(totalUsed, 2)} 度</span>`;
        html += `<span>期間平均每小時用電：約 ${round(avgTotal, 3)} 度/小時</span>`;
      } else if (sortedAsc.length === 1) {
        html += `<span>目前只有一筆資料，無法計算期間平均用電。</span>`;
      } else {
        html += `<span class="warning">總體計算資料異常（可能是時間順序或電表讀數有問題）。</span>`;
      }

      summaryDiv.innerHTML = html;
    }

    // ---- 主表：最近 10 筆，最新在上 ----
    function renderTable() {
      if (!entries || entries.length === 0) {
        tableContainer.innerHTML = "<p>目前尚無紀錄。</p>";
        summaryDiv.textContent = "目前沒有任何紀錄。請先新增一筆電表讀數。";
        updateBillingSummary();
        updateTrendChart();
        return;
      }

      const sortedAsc = [...entries].sort((a, b) => {
        return new Date(a.timestamp) - new Date(b.timestamp);
      });

      renderSummary(sortedAsc);

      const last10Asc = sortedAsc.slice(-10);
      const tableData = last10Asc.slice().reverse(); // 最新在上

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      const headers = [
        "序號",
        "時間",
        "電表讀數（度）",
        "與上次相差（度）",
        "時間間隔（小時）",
        "每小時平均用電（度/小時）",
        "操作"
      ];
      headers.forEach(text => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      const tbody = document.createElement("tbody");

      tableData.forEach((entry, index) => {
        const tr = document.createElement("tr");

        const tdIndex = document.createElement("td");
        tdIndex.textContent = index + 1;
        tr.appendChild(tdIndex);

        const tdTime = document.createElement("td");
        tdTime.textContent = formatDateTime(entry.timestamp);
        tr.appendChild(tdTime);

        const tdReading = document.createElement("td");
        tdReading.textContent = entry.reading;
        tr.appendChild(tdReading);

        const tdDiff = document.createElement("td");
        const tdHours = document.createElement("td");
        const tdAvg = document.createElement("td");

        const idxInAsc = sortedAsc.findIndex(e => e.id === entry.id);
        if (idxInAsc <= 0) {
          tdDiff.textContent = "-";
          tdHours.textContent = "-";
          tdAvg.textContent = "-";
        } else {
          const prev = sortedAsc[idxInAsc - 1];
          const diffReading = entry.reading - prev.reading;
          const diffHours = (new Date(entry.timestamp) - new Date(prev.timestamp)) / (1000 * 60 * 60);

          if (diffHours > 0 && diffReading >= 0) {
            const avg = diffReading / diffHours;
            tdDiff.textContent = round(diffReading, 2);
            tdHours.textContent = round(diffHours, 3);
            tdAvg.textContent = round(avg, 3);
          } else {
            tdDiff.innerHTML = `<span class="warning">異常</span>`;
            tdHours.innerHTML = `<span class="warning">異常</span>`;
            tdAvg.innerHTML = `<span class="warning">異常</span>`;
          }
        }

        tr.appendChild(tdDiff);
        tr.appendChild(tdHours);
        tr.appendChild(tdAvg);

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "刪除";
        delBtn.className = "secondary";
        delBtn.addEventListener("click", async () => {
          if (!confirm("確定要刪除此筆紀錄嗎？")) return;
          try {
            await apiPost({ action: "deleteEntry", id: entry.id });
          } catch (err) {
            alert("刪除失敗：" + err.message);
          }
        });
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      });

      table.appendChild(thead);
      table.appendChild(tbody);
      tableContainer.innerHTML = "";
      tableContainer.appendChild(table);

      updateBillingSummary();
      updateTrendChart();
    }

    // ---- 管理所有紀錄：全部/指定月份，最新在上 ----
    function renderManageTable() {
      if (!manageTableContainer) return;

      if (!entries || entries.length === 0) {
        manageTableContainer.innerHTML = "<p>目前沒有任何紀錄。</p>";
        return;
      }

      let filtered = [...entries];
      const ym = manageMonthInput.value; // "YYYY-MM" 或 ""
      if (ym) {
        filtered = filtered.filter(e => {
          if (!e.timestamp) return false;
          return e.timestamp.substring(0, 7) === ym;
        });
      }

      if (filtered.length === 0) {
        manageTableContainer.innerHTML = "<p>此篩選條件下沒有紀錄。</p>";
        return;
      }

      const sortedAscAll = [...entries].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const sortedDesc = filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      ["序號", "時間", "電表讀數（度）", "與上次相差（度）", "時間間隔（小時）", "每小時平均用電（度/小時）", "操作"].forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      const tbody = document.createElement("tbody");

      sortedDesc.forEach((entry, index) => {
        const tr = document.createElement("tr");

        const tdIndex = document.createElement("td");
        tdIndex.textContent = index + 1;
        tr.appendChild(tdIndex);

        const tdTime = document.createElement("td");
        tdTime.textContent = formatDateTime(entry.timestamp);
        tr.appendChild(tdTime);

        const tdReading = document.createElement("td");
        tdReading.textContent = entry.reading;
        tr.appendChild(tdReading);

        const tdDiff = document.createElement("td");
        const tdHours = document.createElement("td");
        const tdAvg = document.createElement("td");

        const idxInAsc = sortedAscAll.findIndex(e => e.id === entry.id);
        if (idxInAsc <= 0) {
          tdDiff.textContent = "-";
          tdHours.textContent = "-";
          tdAvg.textContent = "-";
        } else {
          const prev = sortedAscAll[idxInAsc - 1];
          const diffReading = entry.reading - prev.reading;
          const diffHours = (new Date(entry.timestamp) - new Date(prev.timestamp)) / (1000 * 60 * 60);
          if (diffHours > 0 && diffReading >= 0) {
            const avg = diffReading / diffHours;
            tdDiff.textContent = round(diffReading, 2);
            tdHours.textContent = round(diffHours, 3);
            tdAvg.textContent = round(avg, 3);
          } else {
            tdDiff.innerHTML = `<span class="warning">異常</span>`;
            tdHours.innerHTML = `<span class="warning">異常</span>`;
            tdAvg.innerHTML = `<span class="warning">異常</span>`;
          }
        }

        tr.appendChild(tdDiff);
        tr.appendChild(tdHours);
        tr.appendChild(tdAvg);

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "刪除";
        delBtn.className = "secondary";
        delBtn.addEventListener("click", async () => {
          if (!confirm("確定要刪除此筆紀錄嗎？")) return;
          try {
            await apiPost({ action: "deleteEntry", id: entry.id });
            renderManageTable();
          } catch (err) {
            alert("刪除失敗：" + err.message);
          }
        });
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      });

      table.appendChild(thead);
      table.appendChild(tbody);
      manageTableContainer.innerHTML = "";
      manageTableContainer.appendChild(table);
    }

    function openManageModal() {
      renderManageTable();
      manageModal.style.display = "flex";
    }

    function closeManageModal() {
      manageModal.style.display = "none";
    }

    // ---- 用電趨勢圖：每小時（整點 bucket）／每日 ----
    function updateTrendChart() {
      const ctx = document.getElementById("trend-chart");
      if (!ctx || !entries || entries.length < 2) {
        if (trendChart) {
          trendChart.destroy();
          trendChart = null;
        }
        return;
      }

      const mode = trendModeSelect.value || "hourly";
      const sortedAsc = [...entries].sort((a, b) => {
        return new Date(a.timestamp) - new Date(b.timestamp);
      });

      let labels = [];
      let data = [];

      if (mode === "hourly") {
        // 以「整點小時」為單位，把每段用電量平均分配到各小時 bucket
        const buckets = {}; // key: hourISO, value: 該小時用電量

        for (let i = 1; i < sortedAsc.length; i++) {
          const prev = sortedAsc[i - 1];
          const cur = sortedAsc[i];

          const t0 = new Date(prev.timestamp);
          const t1 = new Date(cur.timestamp);
          const diffReading = cur.reading - prev.reading;
          const diffHours = (t1 - t0) / (1000 * 60 * 60);

          if (diffHours <= 0 || diffReading < 0) continue;

          const rate = diffReading / diffHours; // 度/小時

          let h = floorToHour(t0);
          if (!h) continue;

          // 逐小時切割 [t0, t1)
          while (h < t1) {
            const nextH = new Date(h.getTime() + 60 * 60 * 1000); // 下一個整點
            const overlapStart = (t0 > h) ? t0 : h;
            const overlapEnd = (t1 < nextH) ? t1 : nextH;
            const overlapMs = overlapEnd - overlapStart;

            if (overlapMs > 0) {
              const overlapHours = overlapMs / (1000 * 60 * 60);
              const key = h.toISOString();
              buckets[key] = (buckets[key] || 0) + rate * overlapHours;
            }

            h = nextH;
          }
        }

        const keys = Object.keys(buckets).sort();
        if (keys.length === 0) {
          if (trendChart) {
            trendChart.destroy();
            trendChart = null;
          }
          return;
        }

        labels = keys.map(k => formatHourLabel(k));
        data = keys.map(k => buckets[k]);

      } else if (mode === "daily") {
        const dailyMap = {};
        for (let i = 1; i < sortedAsc.length; i++) {
          const prev = sortedAsc[i - 1];
          const cur = sortedAsc[i];
          const diffReading = cur.reading - prev.reading;
          const diffHours = (new Date(cur.timestamp) - new Date(prev.timestamp)) / (1000 * 60 * 60);
          if (diffHours > 0 && diffReading >= 0) {
            const dateKey = formatDateOnly(cur.timestamp);
            dailyMap[dateKey] = (dailyMap[dateKey] || 0) + diffReading;
          }
        }
        const keys = Object.keys(dailyMap).sort();
        labels = keys;
        data = keys.map(k => dailyMap[k]);
      }

      if (trendChart) {
        trendChart.destroy();
        trendChart = null;
      }

      if (labels.length === 0) return;

      trendChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: mode === "hourly"
                ? "每小時用電量（度，以整點統計）"
                : "每日用電量（度/日）",
              data,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { maxRotation: 60, minRotation: 0 }
            },
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    // ---- 動作 ----
    async function addEntry() {
      const readingValue = parseFloat(readingInput.value);
      if (isNaN(readingValue)) {
        alert("請輸入正確的電表讀數（數字）。");
        return;
      }

      let recordDate;
      if (useNowCheckbox.checked) {
        recordDate = new Date();
      } else {
        if (!timeInput.value) {
          alert("請輸入紀錄時間，或勾選「使用現在時間」。");
          return;
        }
        recordDate = new Date(timeInput.value);
        if (isNaN(recordDate.getTime())) {
          alert("紀錄時間格式錯誤，請重新選擇。");
          return;
        }
      }

      const entry = {
        id: Date.now() + Math.floor(Math.random() * 1000),
        reading: readingValue,
        timestamp: recordDate.toISOString()
      };

      try {
        await apiPost({ action: "addEntry", entry });
        readingInput.value = "";
      } catch (err) {
        alert("新增失敗：" + err.message);
      }
    }

    async function clearAll() {
      if (!confirm("確定要清除雲端的全部紀錄嗎？此動作無法復原。")) return;
      try {
        await apiPost({ action: "clearAllEntries" });
      } catch (err) {
        alert("清除失敗：" + err.message);
      }
    }

    function exportData() {
      const data = {
        entries,
        billingConfig
      };
      const dataStr = JSON.stringify(data, null, 2);
      const w = window.open("", "_blank");
      if (w) {
        w.document.write("<pre>" + dataStr.replace(/</g, "&lt;") + "</pre>");
      } else {
        alert("瀏覽器阻擋了彈出視窗，請允許後再試一次。");
      }
    }

    async function importBatch() {
      const text = batchInput.value.trim();
      if (!text) {
        alert("請先在文字框輸入要匯入的資料。");
        return;
      }

      const lines = text.split(/\r?\n/);
      const newEntries = [];
      const nowBase = Date.now();
      let success = 0;
      let fail = 0;

      lines.forEach((line, idx) => {
        const trimmed = line.trim();
        if (!trimmed) return;

        let timePart = "";
        let readingPart = "";

        if (trimmed.includes(",")) {
          const parts = trimmed.split(",");
          if (parts.length < 2) { fail++; return; }
          timePart = parts[0].trim();
          readingPart = parts[1].trim();
        } else {
          const parts = trimmed.split(/\s+/);
          if (parts.length < 2) { fail++; return; }
          readingPart = parts[parts.length - 1];
          timePart = parts.slice(0, -1).join(" ");
        }

        const reading = parseFloat(readingPart.replace(/,/g, ""));
        if (isNaN(reading)) {
          fail++;
          return;
        }

        const d = parseUserDateTime(timePart);
        if (!d) {
          fail++;
          return;
        }

        newEntries.push({
          id: nowBase + idx + Math.floor(Math.random() * 1000),
          reading,
          timestamp: d.toISOString()
        });
        success++;
      });

      if (newEntries.length === 0) {
        alert(`沒有成功解析任何資料，失敗 ${fail} 筆。`);
        return;
      }

      try {
        await apiPost({ action: "batchAddEntries", entries: newEntries });
        alert(`匯入完成：成功 ${success} 筆，失敗 ${fail} 筆。`);
      } catch (err) {
        alert("匯入失敗：" + err.message);
      }
    }

    async function saveBillingFromForm() {
      const dateVal = billingStartDateInput.value;
      const readingVal = parseFloat(billingStartReadingInput.value);
      const seasonMode = billingSeasonSelect.value;

      if (!dateVal) {
        alert("請輸入本期起始抄表日。");
        return;
      }
      if (isNaN(readingVal)) {
        alert("請輸入正確的本期起始電表讀數（數字）。");
        return;
      }

      const billing = {
        periodStartDate: dateVal,
        periodStartReading: readingVal,
        seasonMode: seasonMode || "auto"
      };

      try {
        await apiPost({ action: "setBilling", billing });
        alert("本期設定已儲存到雲端。");
      } catch (err) {
        alert("儲存失敗：" + err.message);
      }
    }

    function updateTimeInputState() {
      timeInput.disabled = useNowCheckbox.checked;
    }

    document.addEventListener("DOMContentLoaded", async () => {
      updateTimeInputState();

      addBtn.addEventListener("click", addEntry);
      clearBtn.addEventListener("click", clearAll);
      exportBtn.addEventListener("click", exportData);
      useNowCheckbox.addEventListener("change", updateTimeInputState);
      batchImportBtn.addEventListener("click", importBatch);
      billingSaveBtn.addEventListener("click", saveBillingFromForm);
      trendModeSelect.addEventListener("change", updateTrendChart);

      manageBtn.addEventListener("click", openManageModal);
      manageCloseBtn.addEventListener("click", closeManageModal);
      manageModal.addEventListener("click", (e) => {
        if (e.target === manageModal) closeManageModal();
      });
      manageMonthInput.addEventListener("change", renderManageTable);
      manageResetBtn.addEventListener("click", () => {
        manageMonthInput.value = "";
        renderManageTable();
      });

      try {
        await apiGetAll();
      } catch (err) {
        alert("從雲端載入資料失敗：" + err.message);
      }
    });
  </script>
</body>
</html>
